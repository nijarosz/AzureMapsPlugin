# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AzureMapsPlugin
                                 A QGIS plugin
 Azure Maps plugin for QGIS 3
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-06-04
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Microsoft Corporation
        email                : bretm@microsoft.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import Qt, QSettings, QTranslator, qVersion, QCoreApplication, QVariant
from PyQt5.QtGui import QIcon, QColor
from PyQt5.QtWidgets import QAction, QApplication, QComboBox, QMessageBox, QDockWidget

from qgis.core import *

# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the dialog
from .azure_maps_plugin_dialog import AzureMapsPluginDialog
from .azure_maps_plugin_floor_picker import AzureMapsFloorPicker

import os.path
import requests
import time
import urllib.parse
#import adal

## AADTokenCredentials for multi-factor authentication
#from msrestazure.azure_active_directory import AADTokenCredentials


class AzureMapsPlugin:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'AzureMapsPlugin_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        self.id_map = {}
        self.collection_meta_map = {}

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('AzureMapsPlugin', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=False,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToVectorMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/azure_maps/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Azure Maps'),
            callback=self.run,
            parent=self.iface.mainWindow())

        #self.floor_picker_widget = AzureMapsFloorPicker(self.iface, self.iface.mainWindow())
        #self.iface.addDockWidget(Qt.RightDockWidgetArea, self.floor_picker_widget)

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginVectorMenu(
                self.tr(u'Azure Maps'),
                action)
            self.iface.removeToolBarIcon(action)

        #self.iface.removeDockWidget(self.floor_picker_widget)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = AzureMapsPluginDialog(self.iface)
            self.dlg.getFeaturesButton.clicked.connect(self.get_features_clicked)
            self.picker_floors = []
            self.dlg.floorPicker.currentIndexChanged.connect(self.floor_picker_changed)

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()


    def floor_picker_changed(self, index):
        if index >= 0 and index < len(self.picker_floors):
            ordinal = str(self.picker_floors[index])
            for group in QgsProject.instance().layerTreeRoot().children():
                for child in group.children():
                    if isinstance(child, QgsLayerTreeLayer):
                        layer = child.layer()
                        
                        if "floor" in [field.name() for field in layer.fields()]:
                            layer.setSubsetString("floor = " + ordinal)

                            


    def set_private_atlas_status(self, status):
        self.dlg.privateAtlasStatus.setText(status)
        QApplication.processEvents()


    def get_features_clicked(self):
        self.dlg.getFeaturesButton.setEnabled(False)
        # Determine host name.
        if self.dlg.frontDoorButton.isChecked():
            if self.dlg.stgButton.isChecked():
                host = "https://s-azmaps.azurelbs.com"
            elif self.dlg.testButton.isChecked():
                host = "https://t-azmaps.azurelbs.com"
            elif self.dlg.ciButton.isChecked():
                host = "https://c-azmaps.azurelbs.com"
            elif self.dlg.localhostButton.isChecked():
                host = "http://localhost"
            else:
                host = "https://atlas.microsoft.com"
        else:
            if self.dlg.prodButton.isChecked():
                host = "https://wfs.spatial.mdp.azurelbs.com"
            else:
                host = "https://wfs.spatial.stg.mdp.azurelbs.com"

        # Determine bounding box.
        bbox = ""
        min_x = self.dlg.extentWest.text().strip()
        min_y = self.dlg.extentSouth.text().strip()
        max_x = self.dlg.extentEast.text().strip()
        max_y = self.dlg.extentNorth.text().strip()

        if min_x != "" or min_y != "" or max_x != "" or max_y != "":
            if min_x == "":
                min_x = "-180"
            if min_y == "":
                min_y = "-90"
            if max_x == "":
                max_x = "180"
            if max_y == "":
                max_y = "90"
            bbox = "&" + urllib.parse.urlencode({"bbox": "{},{},{},{}".format(min_x, min_y, max_x, max_y)})

        # Get dataset metadata.
        geodatabase_id = self.dlg.datasetId.text()
        self.wfs_url = host + '/wfs/datasets/' + geodatabase_id + '/'
        self.query_string = "?" + urllib.parse.urlencode({"api-version": "1.0"})
        
        if self.dlg.skButton.isChecked():
            self.query_string += "&" + urllib.parse.urlencode({"subscription-key": self.dlg.sharedKey.text()})

        #if self.dlg.manualADButton.isChecked() and self.dlg.mdpButton.isChecked():
            #self.query_string += "&" + urllib.parse.urlencode({"client-id": self.dlg.manualClientId.text()})

        self.set_private_atlas_status("Getting dataset metadata")
        r = self.get_url(self.wfs_url + "collections" + self.query_string)

        if r.status_code != 200:
            self.set_private_atlas_status("Can't get features. Status code=" + str(r.status_code))
            self.iface.messageBar().pushMessage("Error", "Unable to read dataset metadata. Response status code " + str(r.status_code) + ". " + r.text, level = Qgis.Critical)
            self.dlg.getFeaturesButton.setEnabled(True)
            
        else: # If successful, get all the layers.

            # Group the layers together.
            root = QgsProject.instance().layerTreeRoot()
            group_name = geodatabase_id + bbox
            group = root.findGroup(group_name)

            if group is None:
                group = root.addGroup(group_name)
            else:
                group.removeAllChildren()

            # Get features from each collection.
            collections = r.json()["collections"]
            level_layer = None
            category_level = None
            directory_info_layer = None
            unit_layer = None
            area_element_layer = None
            opening_layer = None
            line_element_layer = None
            point_element_layer = None
            name_layer = None
            facility_layer = None
            vertical_penetration_layer = None

            if geodatabase_id not in self.id_map:
                self.id_map[geodatabase_id] = {}

            if geodatabase_id not in self.collection_meta_map:
                self.collection_meta_map[geodatabase_id] = {}

            id_map = self.id_map[geodatabase_id]
            collection_meta = self.collection_meta_map[geodatabase_id]
            collection_order = ["category", "directory_info", "point_element", "vertical_penetration", "zone", "line_element", "area_element", "opening", "unit", "level", "facility"]
            other_collections = [ c["name"] for c in collections if c["name"] not in collection_order ]

            for name in collection_order + other_collections:
                # Find collection in API definition.
                collection = next(c for c in collections if c["name"] == name)
                print(name)
                links = collection["links"]

                # Get link to item data for collection.
                data_link = next(link for link in links if link["rel"] == "data")

                # Get link to metadata for collection.
                meta_link = next(link for link in links if link["rel"] == "describedBy")

                # Get metadata.
                href = self.patch(meta_link["href"])
                r = self.get_url(href)

                if r.status_code != 200:
                    self.iface.messageBar().pushMessage("Error", "Unable to read collection metadata. Response status code " + str(r.status_code) + ". " + r.text, level = Qgis.Critical)
                    continue

                collection_meta[name] = r.json()

                # Get collection items.
                href = self.patch(data_link["href"])
                layer = self.load_items(name, href + bbox, group, id_map)
                if layer is None:
                    group.removeAllChildren()
                    return
                
                if name == "level":
                    level_layer = layer
                elif name == "category":
                    category_level = layer
                elif name == "directory_info":
                    directory_info_layer = layer
                elif name == "unit":
                    unit_layer = layer
                elif name == "area_element":
                    area_element_layer = layer
                elif name == "opening":
                    opening_layer = layer
                elif name == "line_element":
                    line_element_layer = layer
                elif name == "point_element":
                    point_element_layer = layer
                elif name == "facility":
                    facility_layer = layer
                elif name == "vertical_penetration":
                    vertical_penetration_layer = layer
                elif name == "zone":
                    zone_layer = layer
            if level_layer is None or unit_layer is None:
                self.set_private_atlas_status("One or more required collections is missing")
                return

            self.set_private_atlas_status("Adding private atlas attributes")

            self.level_to_ordinal = {level["id"]: level["ordinal"] for level in level_layer.getFeatures()}

            # Level layer
            floor_index = self.add_helper_attributes(level_layer)
            for feature in level_layer.getFeatures():
                level_layer.changeAttributeValue(feature.id(), floor_index, str(feature["ordinal"]))
                ordinal = feature["ordinal"]

                if ordinal not in self.picker_floors:
                    self.picker_floors.append(ordinal)

            self.add_layer_events(level_layer, id_map, collection_meta)
            level_layer.loadNamedStyle(self.plugin_dir + "/styles/level.qml")

            # Space layer
            floor_index = self.add_helper_attributes(unit_layer)
            space_to_floors = {}
            space_to_ordinals = {}
            for feature in unit_layer.getFeatures():
                level_id = feature["level_id"]
                ordinal = self.level_to_ordinal[level_id]
                floor = ordinal
                unit_layer.changeAttributeValue(feature.id(), floor_index, floor)
                space_to_floors[feature["id"]] = floor
                space_to_ordinals[feature["id"]] = ordinal

            self.add_layer_events(unit_layer, id_map, collection_meta)
            #unit_layer.loadNamedStyle(self.plugin_dir + "/styles/space.qml")

            #list_widget = QgsEditorWidgetSetup("List", {})
            #unit_layer.setEditorWidgetSetup(4, list_widget)

            # Area element layer
            self.add_floors_values(area_element_layer, id_map, space_to_floors, collection_meta)

            # Line element layer
            self.add_floors_values(line_element_layer, id_map, space_to_floors, collection_meta)

            # Point element layer
            self.add_floors_values(point_element_layer, id_map, space_to_floors, collection_meta)

            # Vertical Penetration layer
            if vertical_penetration_layer is not None:
                floor_index = self.add_helper_attributes(vertical_penetration_layer)
                for feature in vertical_penetration_layer.getFeatures():
                    level_id = feature["level_id"]
                    floor = self.level_to_ordinal[level_id]
                    vertical_penetration_layer.changeAttributeValue(feature.id(), floor_index, str(floor))
                self.add_layer_events(vertical_penetration_layer, id_map, collection_meta)

            # Opening layer
            if opening_layer is not None:
                floor_index = self.add_helper_attributes(opening_layer)
                for feature in opening_layer.getFeatures():
                    level_id = feature["level_id"]
                    floor = self.level_to_ordinal[level_id]
                    opening_layer.changeAttributeValue(feature.id(), floor_index, str(floor))
                self.add_layer_events(opening_layer, id_map, collection_meta)
                opening_layer.loadNamedStyle(self.plugin_dir + "/styles/opening.qml")

            if facility_layer is not None:
                self.add_layer_events(facility_layer, id_map, collection_meta)

            if category_level is not None:
                self.add_layer_events(category_level, id_map, collection_meta)

            if directory_info_layer is not None:
                self.add_layer_events(directory_info_layer, id_map, collection_meta)

            if zone_layer is not None:
                self.add_layer_events(zone_layer, id_map, collection_meta)

            # Floor picker
            self.picker_floors.sort()
            self.dlg.floorPicker.clear()

            for ordinal in self.picker_floors:
                self.dlg.floorPicker.addItem(str(ordinal))

            if level_layer is None or unit_layer is None:
                self.set_private_atlas_status("One or more required collections is missing")
                return

            # Set canvas CRS to WGS84 Pseudo-Mercator
            canvas_crs = QgsCoordinateReferenceSystem(3857)
            self.iface.mapCanvas().setDestinationCrs(canvas_crs)

            self.set_private_atlas_status("")
            self.dlg.getFeaturesButton.setEnabled(True)


    # Adds floors and name attributes and returns the index of the first field added (floors).
    def add_helper_attributes(self, layer):
        layer.startEditing()
        provider = layer.dataProvider() 
        field = QgsField("floor", QVariant.String)
        provider.addAttributes([field])           
        layer.updateFields()
        return max(provider.attributeIndexes())


    def add_floors_values(self, layer, id_map, space_to_floors, collection_meta):
        if layer is None:
            return False

        floor_index = self.add_helper_attributes(layer)

        for feature in layer.getFeatures():
            unit_id = feature["unit_id"]
            if unit_id is not None:
                # unit_id = json.loads(unit_id)
                # unit_id = str(unit_id["prefix"]) + str(unit_id["id"])
                floor = space_to_floors.get(unit_id, None)
                if floor is not None:
                    layer.changeAttributeValue(feature.id(), floor_index, str(floor))

        self.add_layer_events(layer, id_map, collection_meta)
        return True


    def add_layer_events(self, layer, id_map, collection_meta):
        layer.commitChanges()
        layer.beforeCommitChanges.connect(lambda: self.on_before_commit_changes(layer, id_map))
        # layer.featuresDeleted.connect(lambda fids: self.on_features_deleted(fids, layer, id_map, collection_meta))


    def patch(self, url):
        if self.dlg.frontDoorButton.isChecked():
            url = url.replace("//atlas.azure-api.net", "//atlas.microsoft.com")
        else:
            url = url.replace("s-azmaps.azurelbs.com", "wfs.spatial.stg.mdp.azurelbs.com")
            url = url.replace("atlas.microsoft.com", "wfs.spatial.mdp.azurelbs.com")

        if self.dlg.skButton.isChecked():
            url += "&" + urllib.parse.urlencode({"subscription-key": self.dlg.sharedKey.text()})

        #if self.dlg.mdpButton.isChecked():
            #url += "&" + urllib.parse.urlencode({"client-id": self.dlg.manualClientId.text()})

        return url


    def get_next_link(self, r_json):
        links = r_json["links"]

        for link in links:
            if link["rel"] == "next":
                return self.patch(link["href"])

        return None


    def load_items(self, name, href, group, id_map):
        self.set_private_atlas_status("Getting " + name + " collection")
        r = self.get_url(href + "&limit=1000")
        layer = None
        page = 1

        if r.status_code != 200:
            self.iface.messageBar().pushMessage("Error", "Unable to read collection. Response status code " + str(r.status_code) + ". " + r.text, level = Qgis.Critical)
            self.dlg.getFeaturesButton.setEnabled(True)
            return

        while r.status_code == 200:

            # Load into a new layer, letting OGR take care of GeoJSON details.
            new_layer = QgsVectorLayer(r.text, "temp", "ogr")
            crs = new_layer.crs().toWkt()

            # If it's the first page, create the memory layer from the WFS temp layer.
            if layer is None:
                wkb_type = new_layer.wkbType()
                if wkb_type == QgsWkbTypes.NoGeometry:
                    wkt = "NoGeometry"
                elif wkb_type == QgsWkbTypes.Point:
                    wkt = "Point"
                elif wkb_type == QgsWkbTypes.MultiPoint:
                    wkt = "MultiPoint"
                elif wkb_type == QgsWkbTypes.LineString:
                    wkt = "LineString"
                elif wkb_type == QgsWkbTypes.MultiLineString:
                    wkt = "MultiLineString"
                elif wkb_type == QgsWkbTypes.Polygon:
                    wkt = "Polygon"
                elif wkb_type == QgsWkbTypes.MultiPolygon:
                    wkt = "MultiPolygon"
                else:
                    return
                
                #layer = QgsVectorLayer(wkt + "?crs=" + crs + "&index=yes", name, "memory")
                maplayer = QgsLayerDefinition.loadLayerDefinitionLayers(self.plugin_dir + "/defs/"+name+".qlr")
                if len(maplayer) != 0:
                    layer = maplayer[0]
                else:
                    layer = QgsVectorLayer(wkt + "?crs=" + crs + "&index=yes", name, "memory")

                # Add fields to layer
                layer.dataProvider().addAttributes(new_layer.dataProvider().fields().toList())
                
                QgsProject.instance().addMapLayer(layer, False)
                group.addLayer(layer)
                
                layer.updateFields()

                # Append the temp layer features to the memory layer.
                layer.startEditing()

                for new_feat in new_layer.getFeatures():
                    feat = QgsFeature()
                    #print(feat.attributes())
                    feat.setFields(new_feat.fields())
                    for field in new_feat.fields().toList():
                        feat.setAttribute(new_feat.fieldNameIndex(field.name()), new_feat.attribute(field.name()))
                    #feat.setAttributes(new_feat.attributes())
                    feat.setGeometry(new_feat.geometry())
                    layer.addFeature(feat)
                # Remove anchor_point and obstruction_area until save is fixed with them
                attrIndexesToBeRemoved = []
                obstructionAreaIndex = layer.dataProvider().fieldNameIndex("obstruction_area")
                if obstructionAreaIndex != -1:
                    attrIndexesToBeRemoved.append(obstructionAreaIndex)
                anchorIndex = layer.dataProvider().fieldNameIndex("anchor_point")
                if anchorIndex != -1:
                    attrIndexesToBeRemoved.append(anchorIndex)
                if len(attrIndexesToBeRemoved) != 0:
                    result = layer.dataProvider().deleteAttributes(attrIndexesToBeRemoved)
                    layer.updateFields()
                
                layer.commitChanges()

                anchorIndex = layer.dataProvider().fieldNameIndex("anchor_point")
                if anchorIndex != -1:
                    print("layer STILL has anchor_point")

                for feature in layer.getFeatures():
                    id_map[layer.name() + ":" + str(feature.id())] = feature["id"]

            next_link = self.get_next_link(r.json())

            if next_link is None:
                break

            page += 1
            self.set_private_atlas_status("Getting " + name + " collection page " + str(page))
            r = self.get_url(next_link)

        return layer


    def on_features_deleted(self, feature_ids, layer, id_map, collection_meta):
        
        # Before we can allow the delete, we need to check if other features
        # are referencing this feature.

        # Build the map of ID-based references between feature classes.
        references = {}

        for collection_name in collection_meta:
            references[collection_name] = []

        for collection_name, collection in collection_meta.items():
            for prop in collection["properties"]:
                prop_type = prop["type"]

                # If property is array, get element type.
                if "array" in prop_type:
                    prop_type = prop_type["array"]

                # Check if property is ID of our collection type.
                if "feature_id" in prop_type:
                    references[prop_type["feature_id"]].append((collection_name, prop["name"]))
                    print(collection_name + "." + prop["name"] + " references " + prop_type["feature_id"])

        # Determine dependency order, dependencies coming after dependors.
        depth = { collection_name: get_depth(collection_name, references) for collection_name in collection_meta }
        print(depth)

        # Group IDs by collection.
        fid_by_collection = {}

        for fid in feature_ids:
            wid = id_map[layer.name() + ":" + str(fid)]
            collection_ids = fid_by_collection.get(wid)

            if collection_ids is None:
                collection_ids = []
                fid_by_collection[wid] = collection_ids

            collection_ids.append(wid)

    def on_before_commit_changes(self, layer, id_map):
        edits = layer.editBuffer()
        deletes = edits.deletedFeatureIds()
        adds = edits.addedFeatures()

        # Determined changed features.
        changes = set()

        for fid in edits.changedGeometries():
            changes.add(fid)

        for fid in edits.changedAttributeValues():
            changes.add(fid)

        for fid in deletes:
            changes.discard(fid)

        exporter = QgsJsonExporter(layer, 7)
        features = []

        for fid in adds:
            feature = layer.getFeature(fid)
            json = '{"action":"create",' + exporter.exportFeature(feature, {}, layer.name().upper() + "0")[1:]
            features.append(json)

        for fid in changes:
            wid = id_map[layer.name() + ":" + str(fid)]
            feature = layer.getFeature(fid)
            json = '{"action":"update",' + exporter.exportFeature(feature, {}, wid)[1:]
            features.append(json)

        for fid in deletes:
            wid = id_map[layer.name() + ":" + str(fid)]
            features.append('{"type":"Feature","action":"delete","id":"' + wid + '","geometry": null,"properties": null}')

        # Submit the changes to the server.
        data = '{"type": "FeatureCollection","features":[' + str.join(", ", features) + ']}'

        # Call Azure Maps patch service to update layer.
        url = self.wfs_url
        r = requests.patch(url + "collections/" + layer.name() + self.query_string, data = data, headers = {"content-type":"application/geo+json"}, verify=False)
        print(r.request.body)
        print(r.request.url)
        print(r.status_code)
        
        # Use message box to alert user of success or failure
        if r.status_code != 200:
            print(r.json()['error']['message'])
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Save to " + layer.name() + " layer has failed!")
            msg.setInformativeText("Edits, deletes or creates have not been saved to your database. Please fix the issues and try saving again.")
            msg.setWindowTitle("Save Failed!")
            msg.setDetailedText("Error message from Azure Maps: " + r.json()['error']['message'])
            msg.exec()
        else:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Information)
            msg.setText("Save to " + layer.name() + " layer has succeeded!")
            msg.setInformativeText("Your edits have been saved to the database.")
            msg.setWindowTitle("Save Successful!")
            msg.exec()
            layer.commitChanges()
        
        floor_index = layer.dataProvider().fieldNameIndex("floor")

        # If floor attribute is found, update floor to updated or created value
        if floor_index != -1:
            for fid in adds:
                level_id = layer.getFeature(fid)["level_id"]
                if level_id is not None:
                    floor = self.level_to_ordinal[level_id]
                    if floor is not None:
                        
                        layer.changeAttributeValue(layer.getFeature(fid).id(), floor_index, str(floor))
        
            for fid in changes:
                level_id = layer.getFeature(fid)["level_id"]
                if level_id is not None:
                    floor = self.level_to_ordinal[level_id]
                    if floor is not None:
                        layer.changeAttributeValue(layer.getFeature(fid).id(), floor_index, str(floor))

    #def authenticate_device_code(self, tenant, client_id):

        # Get authentication context
        #authority_uri = "https://login.microsoftonline.com/" + tenant
        #context = adal.AuthenticationContext(authority_uri, api_version=None)

        # Use the context to get an Azure Maps device code for the client
        #resource_uri = 'https://atlas.microsoft.com/'
        #code = context.acquire_user_code(resource_uri, client_id)
    
        # Ask the user to sign in with device code
        #if QMessageBox.question(None, "Sign in", code['message'] + " Select OK after signing in.", QMessageBox.Ok | QMessageBox.Cancel) != QMessageBox.Ok:
            #return None

        # Get bearer token
        #token = context.acquire_token_with_device_code(resource_uri, code, client_id)
        #print(token)
        #return token
        # thread = QtCore.QThread()
        # worker = AdalWorker(context, resource_uri, code, client_id)
        # worker.moveToThread(thread)
        # worker.finished.connect(self.adal_finished)
        # worker.error.connect(self.adal_error)
        # thread.started.connect(worker.acquire_token)
        # thread.start()

        # Make credentials
        # credentials = AADTokenCredentials(token, client_id)


    #def adal_finished(self, token):
        #pass
        # self.iface.messageBar().pushSuccess("Token acquired", str(token))


    #def adal_error(self, exception, message):
        #pass
        # self.iface.messageBar().pushMessage("Unable to acquire token", message)


    def apply_url(self, url, verb, method):
        print(verb + " " + url)
        start = time.time()
        headers = {}

        #if self.dlg.adButton.isChecked():
            #token = self.authenticate_device_code(self.dlg.tenant.text(), self.dlg.appId.text())
            #token = token["Bearer"]
            #headers["x-ms-client-id"] = self.dlg.clientId.text()
            #headers["Authorization"] = "Bearer " + token

        #if self.dlg.manualADButton.isChecked():
            #if self.dlg.frontDoorButton.isChecked():
                #headers["x-ms-client-id"] = self.dlg.manualClientId.text()
            #headers["Authorization"] = "Bearer " + self.dlg.bearerToken.toPlainText()

        try:
            r = method(url, headers = headers)
            print("{}: {}".format(r.status_code, time.time() - start))

            if "atlas.azure-api.net" in r.text:
                print("Service in PROD is still returning internal hostname")

            return r

        finally:
            pass

        return None


    def get_url(self, url):
        return self.apply_url(url, "GET", requests.get)


    def delete_url(self, url):
        return self.apply_url(url, "DELETE", requests.delete)


def get_depth(collection_name, references):
    ref_list = references.get(collection_name, None)
    if not ref_list:
        return 0
    return 1 + max(get_depth(key, references) for (key, _) in ref_list)



#class AdalWorker(QtCore.QObject):

    #finished = QtCore.pyqtSignal(object)
    #error = QtCore.pyqtSignal(Exception, basestring)

    #def __init__(self, context, resource_uri, code, client_id):
        #QtCore.QObject.__init__(self)
        #self.context = context
        #self.resource_uri = resource_uri
        #self.code = code
        #self.client_id = client_id

    #@QtCore.pyqtSlot()
    #def acquire_token(self):
        #self.token = None
        
        #try:
            #self.token = self.context.acquire_token_with_device_code(self.resource_uri, self.code, self.client_id)

        #except Exception as ex:
            #pass

        #self.finished.emit(self.token)
