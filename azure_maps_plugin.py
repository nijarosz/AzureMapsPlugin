# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AzureMapsPlugin
                                 A QGIS plugin
 Azure Maps plugin for QGIS 3
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-06-04
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Microsoft Corporation
        email                : bretm@microsoft.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *

from qgis.core import *

# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the dialog
from .azure_maps_plugin_dialog import AzureMapsPluginDialog
from .azure_maps_plugin_welcome_message import AzureMapsWelcomeMessage

import os.path
import requests
import time
import urllib.parse
#import adal

## AADTokenCredentials for multi-factor authentication
#from msrestazure.azure_active_directory import AADTokenCredentials

class AzureMapsPlugin:
    """QGIS Plugin Implementation."""
    
    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        s = QSettings()
        locale = s.value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'AzureMapsPlugin_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)
                
        firstRun = s.value("azureMaps/firstrun", None)
        if firstRun is None:
            # Welcome message
            msg = QMessageBox()
            msg.setIconPixmap(QPixmap(':/plugins/azure_maps/icon.png'))
            msg.setText("Welcome to the Azure Maps Plugin!")
            msg.setInformativeText('<a href="https://review.docs.microsoft.com/en-us/azure/azure-maps/azure-maps-qgis-plugin?branch=pr-en-us-90025">Link to Azure Maps Plugin documentation</a>')
            msg.setWindowTitle("Azure Maps")
            msg.exec()
            s.setValue("azureMaps/firstrun", True)
        # Declare instance attributes
        self.actions = []
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.schema_map = {}
        self.new_feature_list = []
        self.id_map = {}
        self.collection_meta_map = {}
        self.openedgroups = []
        self.relation_map = {}

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        win = QWidget()
        l1 = QLabel()
        l1.setPixmap(QPixmap(':/plugins/azure_maps/icon.png'))
        
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('AzureMapsPlugin', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=False,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToVectorMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/azure_maps/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Azure Maps'),
            callback=self.run,
            parent=self.iface.mainWindow())

        #self.floor_picker_widget = AzureMapsFloorPicker(self.iface, self.iface.mainWindow())
        #self.iface.addDockWidget(Qt.RightDockWidgetArea, self.floor_picker_widget)
            
        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        
        for action in self.actions:
            self.iface.removePluginVectorMenu(
                self.tr(u'Azure Maps'),
                action)
            self.iface.removeToolBarIcon(action)

        #self.iface.removeDockWidget(self.floor_picker_widget)


    def run(self):
        """Run method that performs all the real work"""
        
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = AzureMapsPluginDialog(self.iface)
            self.dlg.getFeaturesButton.clicked.connect(self.get_features_clicked)
            self.picker_floors = []
            self.dlg.floorPicker.currentIndexChanged.connect(self.floor_picker_changed)
        self.dlg.getFeaturesButton.setEnabled(True)
       

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()


    def floor_picker_changed(self, index):
        ordinal = str(self.picker_floors[index])
        for group in QgsProject.instance().layerTreeRoot().children():
            for child in group.children():
                if isinstance(child, QgsLayerTreeLayer):
                    layer = child.layer()
                    if "floor" in [field.name() for field in layer.fields()]:
                        layer.rollBack()
                        layer.setSubsetString("floor = " + ordinal)
                    if "levels" in [field.name() for field in layer.fields()]:
                        layer.rollBack()
                        layer.setSubsetString("array_contains(levels, '"+self.ordinal_to_level[int(ordinal)]+"')")
        return

                        

    def set_private_atlas_status(self, status):
        self.dlg.privateAtlasStatus.setText(status)
        QApplication.processEvents()


    def get_features_clicked(self):
        self.dlg.getFeaturesButton.setEnabled(False)
        # Determine host name.
        if self.dlg.frontDoorButton.isChecked():
            if self.dlg.stgButton.isChecked():
                host = "https://s-azmaps.azurelbs.com"
            elif self.dlg.testButton.isChecked():
                host = "https://t-azmaps.azurelbs.com"
            elif self.dlg.ciButton.isChecked():
                host = "https://c-azmaps.azurelbs.com"
            elif self.dlg.localhostButton.isChecked():
                host = "http://localhost"
            else:
                host = "https://atlas.microsoft.com"
        else:
            if self.dlg.prodButton.isChecked():
                host = "https://wfs.spatial.mdp.azurelbs.com"
            else:
                host = "https://wfs.spatial.stg.mdp.azurelbs.com"

        # Determine bounding box.
        bbox = ""
        min_x = self.dlg.extentWest.text().strip()
        min_y = self.dlg.extentSouth.text().strip()
        max_x = self.dlg.extentEast.text().strip()
        max_y = self.dlg.extentNorth.text().strip()

        if min_x != "" or min_y != "" or max_x != "" or max_y != "":
            if min_x == "":
                min_x = "-180"
            if min_y == "":
                min_y = "-90"
            if max_x == "":
                max_x = "180"
            if max_y == "":
                max_y = "90"
            bbox = "&" + urllib.parse.urlencode({"bbox": "{},{},{},{}".format(min_x, min_y, max_x, max_y)})

        # Get dataset metadata.
        geodatabase_id = self.dlg.datasetId.text()
        self.wfs_url = host + '/wfs/datasets/' + geodatabase_id + '/'
        self.query_string = "?" + urllib.parse.urlencode({"api-version": "1.0"})
        
        if self.dlg.skButton.isChecked():
            self.query_string += "&" + urllib.parse.urlencode({"subscription-key": self.dlg.sharedKey.text()})

        #if self.dlg.manualADButton.isChecked() and self.dlg.mdpButton.isChecked():
            #self.query_string += "&" + urllib.parse.urlencode({"client-id": self.dlg.manualClientId.text()})

        self.set_private_atlas_status("Getting dataset metadata")
        r = self.get_url(self.wfs_url + "collections" + self.query_string)

        if r.status_code != 200:
            self.set_private_atlas_status("Can't get features. Status code=" + str(r.status_code))
            self.iface.messageBar().pushMessage("Error", "Unable to read dataset metadata. Response status code " + str(r.status_code) + ". " + r.text, level = Qgis.Critical)
            self.dlg.getFeaturesButton.setEnabled(True)
            
        else: # If successful, get all the layers.
            self.picker_floors = []
            # Group the layers together.
            root = QgsProject.instance().layerTreeRoot()
            group_name = geodatabase_id + bbox
            group = root.findGroup(group_name)
            print(group_name)

            if group is None:
                group = root.addGroup(group_name)
                self.openedgroups.append(group_name)
            else:
                group.removeAllChildren()

            if len(self.openedgroups) > 1:
                for opengroup in self.openedgroups:
                    if opengroup != group_name:
                        oldgroup = root.findGroup(opengroup)
                        if oldgroup is not None:
                            self.iface.messageBar().pushMessage("Error", "Only one dataset can be loaded at once. Please remove group " + opengroup + " and run get features again.", level = Qgis.Critical)
                            self.dlg.getFeaturesButton.setEnabled(True)
                            return

            # Get features from each collection.
            collections = r.json()["collections"]
            level_layer = None
            category_layer = None
            directory_info_layer = None
            unit_layer = None
            area_element_layer = None
            opening_layer = None
            line_element_layer = None
            point_element_layer = None
            name_layer = None
            facility_layer = None
            vertical_penetration_layer = None

            if geodatabase_id not in self.id_map:
                self.id_map[geodatabase_id] = {}

            if geodatabase_id not in self.collection_meta_map:
                self.collection_meta_map[geodatabase_id] = {}

            id_map = self.id_map[geodatabase_id]
            collection_meta = self.collection_meta_map[geodatabase_id]
            collection_order = ["category", "directory_info", "point_element", "vertical_penetration", "zone", "line_element", "area_element", "opening", "unit", "level", "facility"]
            other_collections = [ c["name"] for c in collections if c["name"] not in collection_order ]

            for name in collection_order + other_collections:
                # Find collection in API definition.
                collection = next(c for c in collections if c["name"] == name)
                links = collection["links"]

                # Get link to item data for collection.
                data_link = next(link for link in links if link["rel"] == "data")

                # Get link to metadata for collection.
                meta_link = next(link for link in links if link["rel"] == "describedBy")

                # Get metadata.
                href = self.patch(meta_link["href"])
                
                r = self.get_url(href)
                response = r.json()
                properties = response["properties"]
                names = []
                for attrs in  properties:
                    names.append(attrs["name"])
                self.schema_map[name] = names

                if r.status_code != 200:
                    self.iface.messageBar().pushMessage("Error", "Unable to read collection metadata. Response status code " + str(r.status_code) + ". " + r.text, level = Qgis.Critical)
                    continue

                collection_meta[name] = response

                # Get collection items.
                href = self.patch(data_link["href"])
                layer = self.load_items(name, href + bbox, group, id_map)
                if layer is None:
                    group.removeAllChildren()
                    self.set_private_atlas_status("Failed to load collections. Please try again")
                    self.dlg.getFeaturesButton.setEnabled(True)
                    return
                
                if name == "level":
                    level_layer = layer
                elif name == "category":
                    category_layer = layer
                elif name == "directory_info":
                    directory_info_layer = layer
                elif name == "unit":
                    unit_layer = layer
                elif name == "area_element":
                    area_element_layer = layer
                elif name == "opening":
                    opening_layer = layer
                elif name == "line_element":
                    line_element_layer = layer
                elif name == "point_element":
                    point_element_layer = layer
                elif name == "facility":
                    facility_layer = layer
                elif name == "vertical_penetration":
                    vertical_penetration_layer = layer
                elif name == "zone":
                    zone_layer = layer
            if level_layer is None or len(level_layer) == 0 or unit_layer is None:
                self.set_private_atlas_status("One or more required collections is missing. Please try again")
                self.dlg.getFeaturesButton.setEnabled(True)
                return
            
            self.set_private_atlas_status("Adding private atlas attributes")
            
            # Populate relational map
            self.relation_map["category"] = "category_id"
            self.relation_map["unit"] = "unit_id"
            self.relation_map["level"] = "level_id"
            self.relation_map["facility"] = "facility_id"
            self.relation_map["address"] = "address_id"
            self.relation_map["levels_reached"] = "levels"
            
            # Setup Configs
            category_config = {"Layer": category_layer, "LayerName" : category_layer.name(), "Key" : "id", "Value" : "name" }
            unit_config = {"Layer": unit_layer, "LayerName" : unit_layer.name(), "Key" : "id", "Value" : "name"}
            level_config = {"Layer": level_layer, "LayerName" : level_layer.name(), "Key" : "id", "Value" : "name"}
            levels_config = {"Layer": level_layer, "LayerName" : level_layer.name(), "Key" : "id", "Value" : "name", "AllowMulti" : True}
            facility_config = {"Layer": facility_layer, "LayerName" : facility_layer.name(), "Key" : "id", "Value" : "name"}
            directory_config = {"Layer": directory_info_layer, "LayerName" : directory_info_layer.name(), "Key" : "id", "Value" : "name"}
            
            self.level_to_ordinal = {level["id"]: level["ordinal"] for level in level_layer.getFeatures()}
            self.ordinal_to_level = {level["ordinal"]: level["id"] for level in level_layer.getFeatures()}
            
            # Level layer
            floor_index = self.add_helper_attributes(level_layer)
            fac_index = self.add_widget(level_layer, "facility", "ValueRelation", facility_config)
            for feature in level_layer.getFeatures():
                level_layer.changeAttributeValue(feature.id(), floor_index, str(feature["ordinal"]))
                level_layer.changeAttributeValue(feature.id(), fac_index, feature.attribute(self.relation_map["facility"]))
                ordinal = feature["ordinal"]
                if ordinal not in self.picker_floors:
                    self.picker_floors.append(ordinal)
            self.add_widget(level_layer, "name_alt", "TextEdit") 
            self.add_widget(level_layer, "name_subtitle", "TextEdit")
            level_layer.loadNamedStyle(self.plugin_dir + "/styles/level.qml")
            self.add_layer_events(level_layer, id_map, collection_meta)

            # Unit layer
            floor_index = self.add_helper_attributes(unit_layer)
            self.space_to_floors = {}
            space_to_ordinals = {}
            cat_index = self.add_widget(unit_layer, "category", "ValueRelation", category_config)
            lvl_index = self.add_widget(unit_layer, "level", "ValueRelation", level_config)
            dir_index = self.add_widget(unit_layer, "address", "ValueRelation", directory_config)
            for feature in unit_layer.getFeatures():
                level_id = feature["level_id"]
                ordinal = self.level_to_ordinal[level_id]
                floor = ordinal
                unit_layer.changeAttributeValue(feature.id(), floor_index, floor)
                unit_layer.changeAttributeValue(feature.id(), cat_index, feature.attribute(self.relation_map["category"]))
                unit_layer.changeAttributeValue(feature.id(), lvl_index, feature.attribute(self.relation_map["level"]))
                unit_layer.changeAttributeValue(feature.id(), dir_index, feature.attribute(self.relation_map["address"]))
                self.space_to_floors[feature["id"]] = floor
                space_to_ordinals[feature["id"]] = ordinal            
            self.add_widget(unit_layer, "navigable_by", "List")  
            self.add_layer_events(unit_layer, id_map, collection_meta)
            #unit_layer.loadNamedStyle(self.plugin_dir + "/styles/space.qml")

            #list_widget = QgsEditorWidgetSetup("List", {})
            #unit_layer.setEditorWidgetSetup(4, list_widget)

            # Area element layer
            cat_index = self.add_widget(area_element_layer, "category", "ValueRelation", category_config)
            unit_index = self.add_widget(area_element_layer, "unit", "ValueRelation", unit_config)
            for feature in area_element_layer.getFeatures():
                area_element_layer.changeAttributeValue(feature.id(), cat_index, feature.attribute(self.relation_map["category"]))
                area_element_layer.changeAttributeValue(feature.id(), unit_index, feature.attribute(self.relation_map["unit"])) 
            self.add_widget(area_element_layer, "name", "TextEdit") 
            self.add_widget(area_element_layer, "name_alt", "TextEdit") 
            self.add_widget(area_element_layer, "name_subtitle", "TextEdit")
            self.add_floors_values(area_element_layer, id_map, self.space_to_floors, collection_meta)

            # Line element layer
            cat_index = self.add_widget(line_element_layer, "category", "ValueRelation", category_config)
            unit_index = self.add_widget(line_element_layer, "unit", "ValueRelation", unit_config)
            for feature in line_element_layer.getFeatures():
                line_element_layer.changeAttributeValue(feature.id(), cat_index, feature.attribute(self.relation_map["category"]))
                line_element_layer.changeAttributeValue(feature.id(), unit_index, feature.attribute(self.relation_map["unit"]))
            self.add_widget(line_element_layer, "name", "TextEdit") 
            self.add_widget(line_element_layer, "name_alt", "TextEdit") 
            self.add_widget(line_element_layer, "name_subtitle", "TextEdit")
            self.add_floors_values(line_element_layer, id_map, self.space_to_floors, collection_meta)
            

            # Point element layer
            cat_index = self.add_widget(point_element_layer, "category", "ValueRelation", category_config)
            unit_index = self.add_widget(point_element_layer, "unit", "ValueRelation", unit_config)
            for feature in point_element_layer.getFeatures():
                point_element_layer.changeAttributeValue(feature.id(), cat_index, feature.attribute(self.relation_map["category"]))
                point_element_layer.changeAttributeValue(feature.id(), unit_index, feature.attribute(self.relation_map["unit"]))
            self.add_floors_values(point_element_layer, id_map, self.space_to_floors, collection_meta)
            self.add_widget(point_element_layer, "name", "TextEdit") 
            self.add_widget(point_element_layer, "name_alt", "TextEdit") 
            self.add_widget(point_element_layer, "name_subtitle", "TextEdit")
            

            # Vertical Penetration layer
            if vertical_penetration_layer is not None:
                floor_index = self.add_helper_attributes(vertical_penetration_layer)
                cat_index = self.add_widget(vertical_penetration_layer, "category", "ValueRelation", category_config)
                lvl_index = self.add_widget(vertical_penetration_layer, "level", "ValueRelation", level_config)
                for feature in vertical_penetration_layer.getFeatures():
                    level_id = feature["level_id"]
                    floor = self.level_to_ordinal[level_id]
                    vertical_penetration_layer.changeAttributeValue(feature.id(), floor_index, str(floor))
                    vertical_penetration_layer.changeAttributeValue(feature.id(), cat_index, feature.attribute(self.relation_map["category"]))
                    vertical_penetration_layer.changeAttributeValue(feature.id(), lvl_index, feature.attribute(self.relation_map["level"]))
                self.add_widget(vertical_penetration_layer, "navigable_by", "List") 
                self.add_layer_events(vertical_penetration_layer, id_map, collection_meta)

            # Opening layer
            if opening_layer is not None:
                floor_index = self.add_helper_attributes(opening_layer)
                cat_index = self.add_widget(opening_layer, "category", "ValueRelation", category_config)
                lvl_index = self.add_widget(opening_layer, "level", "ValueRelation", level_config)
                for feature in opening_layer.getFeatures():
                    level_id = feature["level_id"]
                    floor = self.level_to_ordinal[level_id]
                    opening_layer.changeAttributeValue(feature.id(), floor_index, str(floor))
                    opening_layer.changeAttributeValue(feature.id(), cat_index, feature.attribute(self.relation_map["category"]))
                    opening_layer.changeAttributeValue(feature.id(), lvl_index, feature.attribute(self.relation_map["level"]))
                self.add_widget(opening_layer, "navigable_by", "List")  
                self.add_widget(opening_layer, "access_right_to_left", "List")  
                self.add_widget(opening_layer, "access_left_to_right", "List")  
                opening_layer.loadNamedStyle(self.plugin_dir + "/styles/opening.qml")
                self.add_layer_events(opening_layer, id_map, collection_meta)

            # Facility layer
            if facility_layer is not None:
                cat_index = self.add_widget(facility_layer, "category", "ValueRelation", category_config)
                dir_index = self.add_widget(facility_layer, "address", "ValueRelation", directory_config)
                for feature in facility_layer.getFeatures():
                    facility_layer.changeAttributeValue(feature.id(), cat_index, feature.attribute(self.relation_map["category"]))
                    facility_layer.changeAttributeValue(feature.id(), dir_index, feature.attribute(self.relation_map["address"]))
                self.add_widget(facility_layer, "occupants", "List") 
                self.add_layer_events(facility_layer, id_map, collection_meta)

            # Category Layer
            if category_layer is not None:
                self.add_layer_events(category_layer, id_map, collection_meta)

            # Directory Info layer
            if directory_info_layer is not None:
                self.add_widget(directory_info_layer, "admin_divisions", "List") 
                self.add_layer_events(directory_info_layer, id_map, collection_meta)

            # Zone layer
            if zone_layer is not None:
                cat_index = self.add_widget(zone_layer, "category", "ValueRelation", category_config)
                lvls_index = self.add_widget(zone_layer, "levels_reached", "ValueRelation", levels_config)
                for feature in zone_layer.getFeatures():
                    zone_layer.changeAttributeValue(feature.id(), cat_index, feature.attribute(self.relation_map["category"]))
                    zone_layer.changeAttributeValue(feature.id(), lvls_index, feature.attribute(self.relation_map["levels_reached"]))
                self.add_widget(zone_layer, "name_alt", "TextEdit") 
                self.add_widget(zone_layer, "name_subtitle", "TextEdit")
                self.add_widget(zone_layer, "levels", "List")  
                self.add_layer_events(zone_layer, id_map, collection_meta)    

            # Floor picker
            self.picker_floors.sort()
            self.dlg.floorPicker.clear()

            for ordinal in self.picker_floors:
                self.dlg.floorPicker.addItem(str(ordinal))

            if level_layer is None or unit_layer is None:
                self.set_private_atlas_status("One or more required collections is missing")
                return

            # Set canvas CRS to WGS84 Pseudo-Mercator
            canvas_crs = QgsCoordinateReferenceSystem(3857)
            self.iface.mapCanvas().setDestinationCrs(canvas_crs)

            self.set_private_atlas_status("Load complete")
            self.dlg.getFeaturesButton.setEnabled(True)
            

    def add_widget(self, layer, fieldName, widgetType, config = {}):
        levelsIndex = layer.dataProvider().fieldNameIndex(fieldName)
        if levelsIndex == -1:
            layer.startEditing()
            widget = QgsEditorWidgetSetup(widgetType, config)
            field = QgsField(fieldName, QVariant.String)
            layer.dataProvider().addAttributes([field])        
            layer.updateFields()
            layer.setEditorWidgetSetup(layer.dataProvider().fieldNameIndex(fieldName), widget) 
            return layer.dataProvider().fieldNameIndex(fieldName)
        return levelsIndex

    # Adds floors and name attributes and returns the index of the first field added (floors).
    def add_helper_attributes(self, layer):
        floor = layer.dataProvider().fieldNameIndex("floor")
        if floor == -1:
            layer.startEditing()
            provider = layer.dataProvider() 
            field = QgsField("floor", QVariant.String)
            provider.addAttributes([field])           
            layer.updateFields()
            hiddenWidget = QgsEditorWidgetSetup("Hidden", {})
            layer.setEditorWidgetSetup(max(provider.attributeIndexes()), hiddenWidget)
            #print(provider.fields()[max(provider.attributeIndexes())].editorWidgetSetup().type())   
            return max(provider.attributeIndexes())
        else:
            return floor

    def add_floors_values(self, layer, id_map, space_to_floors, collection_meta):
        if layer is None:
            return False

        floor_index = self.add_helper_attributes(layer)

        for feature in layer.getFeatures():
            unit_id = feature["unit_id"]
            if unit_id is not None:
                # unit_id = json.loads(unit_id)
                # unit_id = str(unit_id["prefix"]) + str(unit_id["id"])
                floor = self.space_to_floors.get(unit_id, None)
                if floor is not None:
                    layer.changeAttributeValue(feature.id(), floor_index, str(floor))

        self.add_layer_events(layer, id_map, collection_meta)
        return True


    def add_layer_events(self, layer, id_map, collection_meta):
        layer.commitChanges()
        layer.beforeCommitChanges.connect(lambda: self.on_before_commit_changes(layer, id_map))
        layer.committedFeaturesAdded.connect(lambda: self.committed_features_added(layer, id_map))
        # layer.featuresDeleted.connect(lambda fids: self.on_features_deleted(fids, layer, id_map, collection_meta))


    def patch(self, url):
        if self.dlg.frontDoorButton.isChecked():
            url = url.replace("//atlas.azure-api.net", "//atlas.microsoft.com")
        else:
            url = url.replace("s-azmaps.azurelbs.com", "wfs.spatial.stg.mdp.azurelbs.com")
            url = url.replace("atlas.microsoft.com", "wfs.spatial.mdp.azurelbs.com")

        if self.dlg.skButton.isChecked():
            url += "&" + urllib.parse.urlencode({"subscription-key": self.dlg.sharedKey.text()})

        #if self.dlg.mdpButton.isChecked():
            #url += "&" + urllib.parse.urlencode({"client-id": self.dlg.manualClientId.text()})

        return url


    def get_next_link(self, r_json):
        links = r_json["links"]
        for link in links:
            if link["rel"] == "next":
                return self.patch(link["href"])

        return None


    def load_items(self, name, href, group, id_map):
        self.set_private_atlas_status("Getting " + name + " collection")
        r = self.get_url(href + "&limit=1000")
        layer = None
        page = 1

        if r.status_code != 200:
            self.iface.messageBar().pushMessage("Error", "Unable to read collection. Response status code " + str(r.status_code) + ". " + r.text, level = Qgis.Critical)
            self.dlg.getFeaturesButton.setEnabled(True)
            return

        while r.status_code == 200:

            # Load into a new layer, letting OGR take care of GeoJSON details.
            new_layer = QgsVectorLayer(r.text, "temp", "ogr")
            crs = new_layer.crs().toWkt()

            # If it's the first page, create the memory layer from the WFS temp layer.
            if layer is None:
                wkb_type = new_layer.wkbType()
                if wkb_type == QgsWkbTypes.NoGeometry:
                    wkt = "NoGeometry"
                elif wkb_type == QgsWkbTypes.Point:
                    wkt = "Point"
                elif wkb_type == QgsWkbTypes.MultiPoint:
                    wkt = "MultiPoint"
                elif wkb_type == QgsWkbTypes.LineString:
                    wkt = "LineString"
                elif wkb_type == QgsWkbTypes.MultiLineString:
                    wkt = "MultiLineString"
                elif wkb_type == QgsWkbTypes.Polygon:
                    wkt = "Polygon"
                elif wkb_type == QgsWkbTypes.MultiPolygon:
                    wkt = "MultiPolygon"
                else:
                    return
                
                #layer = QgsVectorLayer(wkt + "?crs=" + crs + "&index=yes", name, "memory")
                maplayer = QgsLayerDefinition.loadLayerDefinitionLayers(self.plugin_dir + "/defs/"+name+".qlr")
                if len(maplayer) != 0:
                    layer = maplayer[0]
                else:
                    layer = QgsVectorLayer(wkt + "?crs=" + crs + "&index=yes", name, "memory")
                # Add fields to layer
                layer.dataProvider().addAttributes(new_layer.dataProvider().fields().toList())
                QgsProject.instance().addMapLayer(layer, False)
                group.addLayer(layer)
                
                layer.updateFields()

            # Append the temp layer features to the memory layer.
            layer.startEditing()

            for new_feat in new_layer.getFeatures():
                feat = QgsFeature()
                #print(feat.attributes())
                feat.setFields(new_feat.fields())
                for field in new_feat.fields().toList():
                    feat.setAttribute(new_feat.fieldNameIndex(field.name()), new_feat.attribute(field.name()))
                #feat.setAttributes(new_feat.attributes())
                feat.setGeometry(new_feat.geometry())
                layer.addFeature(feat)
            # Remove anchor_point and obstruction_area until save is fixed with them
            attrIndexesToBeRemoved = []
            obstructionAreaIndex = layer.dataProvider().fieldNameIndex("obstruction_area")
            if obstructionAreaIndex != -1:
                attrIndexesToBeRemoved.append(obstructionAreaIndex)
            anchorIndex = layer.dataProvider().fieldNameIndex("anchor_point")
            if anchorIndex != -1:
                attrIndexesToBeRemoved.append(anchorIndex)
            if len(attrIndexesToBeRemoved) != 0:
                result = layer.dataProvider().deleteAttributes(attrIndexesToBeRemoved)
                layer.updateFields()
            layer.commitChanges()

            for feature in layer.getFeatures():
                id_map[layer.name() + ":" + str(feature.id())] = feature["id"]

            next_link = self.get_next_link(r.json())

            if next_link is None:
                break

            page += 1
            self.set_private_atlas_status("Getting " + name + " collection page " + str(page))
            r = self.get_url(next_link)

        return layer


    def on_features_deleted(self, feature_ids, layer, id_map, collection_meta):
        
        # Before we can allow the delete, we need to check if other features
        # are referencing this feature.

        # Build the map of ID-based references between feature classes.
        references = {}

        for collection_name in collection_meta:
            references[collection_name] = []

        for collection_name, collection in collection_meta.items():
            for prop in collection["properties"]:
                prop_type = prop["type"]

                # If property is array, get element type.
                if "array" in prop_type:
                    prop_type = prop_type["array"]

                # Check if property is ID of our collection type.
                if "feature_id" in prop_type:
                    references[prop_type["feature_id"]].append((collection_name, prop["name"]))
                    print(collection_name + "." + prop["name"] + " references " + prop_type["feature_id"])

        # Determine dependency order, dependencies coming after dependors.
        depth = { collection_name: get_depth(collection_name, references) for collection_name in collection_meta }
        print(depth)

        # Group IDs by collection.
        fid_by_collection = {}

        for fid in feature_ids:
            wid = id_map[layer.name() + ":" + str(fid)]
            collection_ids = fid_by_collection.get(wid)

            if collection_ids is None:
                collection_ids = []
                fid_by_collection[wid] = collection_ids

            collection_ids.append(wid)

    # Use this to access newly created feature after Azure Maps successfuly creates a features
    def committed_features_added(self, layer, id_map):
        features_to_edit = []
        features = layer.getFeatures()
        for feature in features:
            if feature["id"] in self.new_feature_list and feature.id() > 0:
                id_map[layer.name() + ":" + str(feature.id())] = feature["id"]                
        self.new_feature_list = []
        

    def on_before_commit_changes(self, layer, id_map):
        edits = layer.editBuffer()
        deletes = edits.deletedFeatureIds()
        adds = edits.addedFeatures()

        # Determined changed features.
        changes = set()

        for fid in edits.changedGeometries():
            changes.add(fid)

        for fid in edits.changedAttributeValues():
            changes.add(fid)

        for fid in deletes:
            changes.discard(fid)
        exporter = QgsJsonExporter(layer, 7)
        if len(changes) != 0  or len(adds) != 0:
            fid = 0
            feature = None
            if len(changes) != 0:
                for f in changes:
                    fid = f
                    break
            else:
                for f in adds:
                    fid = f
                    break
            feature = layer.getFeature(fid)
            includedList= []
            attributeList = self.schema_map[layer.name()]
            for attr in attributeList:
                if attr != "original_id":
                    index = feature.fieldNameIndex(attr)
                    if index != -1:
                        includedList.append(index)
            exporter.setAttributes(includedList)
        features = []

        for fid in adds:
            feature = layer.getFeature(fid)
            self.update_ids(layer, feature)
            feature = layer.getFeature(fid)
            json = '{"action":"create",' + exporter.exportFeature(feature, {}, fid)[1:]
            features.append(json)

        for fid in changes:
            feature = layer.getFeature(fid)
            self.update_ids(layer, feature)
            feature = layer.getFeature(fid)
            if fid > 0:
                wid = id_map[layer.name() + ":" + str(fid)]
                json = '{"action":"update",' + exporter.exportFeature(feature, {}, wid)[1:]
            else:
                json = '{"action":"create",' + exporter.exportFeature(feature, {}, fid)[1:]
            features.append(json)

        for fid in deletes:
            wid = id_map[layer.name() + ":" + str(fid)]
            features.append('{"type":"Feature","action":"delete","id":"' + wid + '","geometry": null,"properties": null}')

        # Submit the changes to the server.
        data = '{"type": "FeatureCollection","features":[' + str.join(", ", features) + ']}'

        # Call Azure Maps patch service to update layer.
        url = self.wfs_url
        r = requests.patch(url + "collections/" + layer.name() + self.query_string, data = data, headers = {"content-type":"application/geo+json"}, verify=False)
        print(r.request.body)
        print(r.request.url)
        print(r.status_code)
        
        # Use message box to alert user of success or failure
        if r.status_code != 200:
            print(r.json()['error']['message'])
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Save to " + layer.name() + " layer has failed!")
            msg.setInformativeText("Edits, deletes or creates have not been saved to your database. Please fix the issues and try saving again.")
            msg.setWindowTitle("Save Failed!")
            msg.setDetailedText("Error message from Azure Maps: " + r.json()['error']['message'])
            msg.exec()
        else:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Information)
            msg.setText("Save to " + layer.name() + " layer has succeeded!")
            msg.setInformativeText("Your edits have been saved to the database.")
            msg.setWindowTitle("Save Successful!")
            msg.exec()
        
        floor_index = layer.dataProvider().fieldNameIndex("floor")
        created = None
        if adds is not None and len(adds) != 0:
            created = r.json()['createdfeatures']
        # If floor attribute is found, update floor to updated or created value
        if floor_index != -1:
            self.update_floors(adds, layer, floor_index, created)
            self.update_floors(changes, layer, floor_index, created)
        else:
            if created is not None:
                for fid in adds:
                    # Update newly created feature with ID from Azure Maps response
                    id_index = layer.dataProvider().fieldNameIndex("id")
                    for ids in created:
                        if int(ids['user_supplied_id']) == fid:
                            newId = ids['service_assigned_id']
                            layer.changeAttributeValue(layer.getFeature(fid).id(), id_index, newId)
                            # Add feature to list to accessed after it's actually created in QGIS (gets and ID above 0)
                            self.new_feature_list.append(newId)
            
    def update_ids(self, layer, feature):
        for key in self.relation_map:
            #print("key: " + key + " value: " + self.relation_map[key])
            if feature.fieldNameIndex(key) != -1:
                # Temp fix until schema is changed - PBI 6216025
                if key == "levels_reached":
                    lvl_list = feature.attribute(self.relation_map[key])
                    lvls_reached = feature.attribute(key)
                    for lvl in lvls_reached:
                        if lvl not in lvl_list:
                            lvl_list.append(lvl)
                    layer.changeAttributeValue(feature.id(), feature.fieldNameIndex(self.relation_map[key]), lvl_list)
                else:
                    layer.changeAttributeValue(feature.id(), feature.fieldNameIndex(self.relation_map[key]), feature.attribute(key))
                
            
    
    def update_floors(self, new, layer, floor_index, created):
        for fid in new:
            feature = layer.getFeature(fid)
            if feature.fieldNameIndex("level_id") != -1:
                level_id = feature["level_id"]
                floor = self.level_to_ordinal[level_id]
                if floor is not None:
                    layer.changeAttributeValue(layer.getFeature(fid).id(), floor_index, str(floor))
            elif feature.fieldNameIndex("unit_id") != -1:
                unit_id = feature["unit_id"]
                if unit_id is not None:
                    floor = self.space_to_floors.get(unit_id, None)
                    if floor is not None:
                        layer.changeAttributeValue(layer.getFeature(fid).id(), floor_index, str(floor))
            elif feature.fieldNameIndex("ordinal") != -1:
                ordinal = feature["ordinal"]
                if ordinal is not None:
                    layer.changeAttributeValue(layer.getFeature(fid).id(), floor_index, str(ordinal))
                    self.dlg.floorPicker.clear()
                    remove = self.level_to_ordinal[feature["id"]]
                    self.picker_floors.remove(remove)
                    for feature in layer.getFeatures():
                        ordinal = feature["ordinal"]
                        if ordinal not in self.picker_floors:
                            self.picker_floors.append(ordinal)
                    self.picker_floors.sort()
                    for ordinal in self.picker_floors:
                        self.dlg.floorPicker.addItem(str(ordinal))
                    self.level_to_ordinal[feature["id"]] = feature["ordinal"]
                    del self.ordinal_to_level[remove]
                    self.ordinal_to_level[feature["ordinal"]] = feature["id"]
            if created is not None:
                # Update newly created feature with ID from Azure Maps response
                id_index = layer.dataProvider().fieldNameIndex("id")
                for ids in created:
                    if ids['user_supplied_id'] is not None and int(ids['user_supplied_id']) == fid:
                        newId = ids['service_assigned_id']
                        layer.changeAttributeValue(layer.getFeature(fid).id(), id_index, newId)
                        # Add feature to list to be accessed after it's actually created in QGIS (gets and ID above 0)
                        self.new_feature_list.append(newId)

    #def authenticate_device_code(self, tenant, client_id):

        # Get authentication context
        #authority_uri = "https://login.microsoftonline.com/" + tenant
        #context = adal.AuthenticationContext(authority_uri, api_version=None)

        # Use the context to get an Azure Maps device code for the client
        #resource_uri = 'https://atlas.microsoft.com/'
        #code = context.acquire_user_code(resource_uri, client_id)
    
        # Ask the user to sign in with device code
        #if QMessageBox.question(None, "Sign in", code['message'] + " Select OK after signing in.", QMessageBox.Ok | QMessageBox.Cancel) != QMessageBox.Ok:
            #return None

        # Get bearer token
        #token = context.acquire_token_with_device_code(resource_uri, code, client_id)
        #print(token)
        #return token
        # thread = QtCore.QThread()
        # worker = AdalWorker(context, resource_uri, code, client_id)
        # worker.moveToThread(thread)
        # worker.finished.connect(self.adal_finished)
        # worker.error.connect(self.adal_error)
        # thread.started.connect(worker.acquire_token)
        # thread.start()

        # Make credentials
        # credentials = AADTokenCredentials(token, client_id)


    #def adal_finished(self, token):
        #pass
        # self.iface.messageBar().pushSuccess("Token acquired", str(token))


    #def adal_error(self, exception, message):
        #pass
        # self.iface.messageBar().pushMessage("Unable to acquire token", message)


    def apply_url(self, url, verb, method):
        print(verb + " " + url)
        start = time.time()
        headers = {}

        #if self.dlg.adButton.isChecked():
            #token = self.authenticate_device_code(self.dlg.tenant.text(), self.dlg.appId.text())
            #token = token["Bearer"]
            #headers["x-ms-client-id"] = self.dlg.clientId.text()
            #headers["Authorization"] = "Bearer " + token

        #if self.dlg.manualADButton.isChecked():
            #if self.dlg.frontDoorButton.isChecked():
                #headers["x-ms-client-id"] = self.dlg.manualClientId.text()
            #headers["Authorization"] = "Bearer " + self.dlg.bearerToken.toPlainText()

        try:
            r = method(url, headers = headers)
            print("{}: {}".format(r.status_code, time.time() - start))

            if "atlas.azure-api.net" in r.text:
                print("Service in PROD is still returning internal hostname")

            return r

        finally:
            pass

        return None


    def get_url(self, url):
        return self.apply_url(url, "GET", requests.get)


    def delete_url(self, url):
        return self.apply_url(url, "DELETE", requests.delete)


def get_depth(collection_name, references):
    ref_list = references.get(collection_name, None)
    if not ref_list:
        return 0
    return 1 + max(get_depth(key, references) for (key, _) in ref_list)



#class AdalWorker(QtCore.QObject):

    #finished = QtCore.pyqtSignal(object)
    #error = QtCore.pyqtSignal(Exception, basestring)

    #def __init__(self, context, resource_uri, code, client_id):
        #QtCore.QObject.__init__(self)
        #self.context = context
        #self.resource_uri = resource_uri
        #self.code = code
        #self.client_id = client_id

    #@QtCore.pyqtSlot()
    #def acquire_token(self):
        #self.token = None
        
        #try:
            #self.token = self.context.acquire_token_with_device_code(self.resource_uri, self.code, self.client_id)

        #except Exception as ex:
            #pass

        #self.finished.emit(self.token)
